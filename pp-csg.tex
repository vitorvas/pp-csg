\documentclass{elsarticle}

\author{Vitor Vasconcelos, Andr\'e Campagnole, Daniel Campolina and 
Graiciany Barros}
\title{A visualizer for Serpent Nuclear Code geometries}

\begin{document}

\maketitle

\section{Why bother}

I can cite my professor Claudio Esperanca\cite{Esperanca1990}.
It is also worth citing the Los Alamos White Paper\cite{Spencer2017}.
The paper of Boyd\cite{Boyd2015} presents a nice open software worth citing. In this paper, a new
library for CS (or CSG) graphic elements is described. The proposed work does not investigate better
implementations or algoritms for CSG, but clear explanations of the algoritms used in general Monte Carlo
codes are given. These algoritms and data structures can be used in the present work and allied to
VTK.

A fundamental decision is: use Python or C++ to implement this code? The former has the advantage of syntax. Moreover,
this is an opportunite to gain knowledge in Python and all the tools related to it, like test modules and documentation
modules. As a drawback, the examples of VTK are rarely provided in Python. C++, on the other hand, is far more complex
to code but have many examples on VTK website. This is also a language I know and \textbf{need} to re-train on. The
choice is pending over Python, but I'm not yet sure.

Another main issue before even starting to code: how \textbf{Serpent2} implements the geometry/elements functions. This
can be the best reference for implementing the visualization software.

\section{Introduction (Justification)}

There is no question about the usefulness of Monte Carlo codes to the various
fields of radiation applications, namely, nuclear physics, nuclear reactors,
radioprotection, dosis assesment, among many others \cite[applications].

A lot of time and energy were spent implementing algorithms intended to improve
various aspects of the physics simulated by these codes. The most popular of
them is MCNP\textregistered \cite{mcnp}, followed by Fluka\cite{fluka} and, more
recently, Serpent\cite{serpent}. The latter, aimed mostly to criticality and neutron analysis.

The maturity, robustness and aplicability of these codes cannot be questioned.
However, since resources for sofware development are also a limited asset,
usually these are applied to add new features concerning mostly the physical aspects of the software and the usability is usually neglected.

The urgent need for a better form of software interaction related to MCNP
is well presented by Spencer\cite{Spencer2017}, taking in account a set of gains that would emerge simply from the improvement of the way on how geometry definition is done for MCNP.

Despite being a much younger software than MCNP, Serpent has at least one limitation common to MCNP: the description of the problem's geometry. This affirmation is by no means a criticism to its input standard, since it has a comprehensive form of geometry
definition. Nervetheless, this does not mean neither that it cannot be improved.

With that in mind, this paper presents a rather simple - and expectedly expansive -
graphics user interface aimed to the visualization of Serpent's geometry input
in 3D. This version generates VTK output files to be read and manipulated by
the increasely present scientific visualization tool Paraview\cite{paraview}.

\section{Objective}


\section{Geometry in Serpent}

As many Monte Carlo particle simulation codes, Serpent makes use of Computational Solid Geometry (CSG) to
describe the geometry of the elements being simulated. Serpent calls it: universe-based geometry modelling.
%Besides the conventional square and hexagonal lattices used in nuclear reactor %simulations, Serpent also
%offers a special geometry type for the simulation of CANDU type reactors and also randomly-dispersed
%particle fuels.

%Serpent is the first nuclear reactors Monte Carlo code to natively support CAD and %unstructured mesh based geometries\cite{serpent-openfoam-mesh}, which are not 
%(yet) in the scope of the implementation presented in this paper.

%The building block 
%of geometry is the cell, which is a region of space delimited by boundary 
%surfaces. Cells are filled with 

\subsection{How \textit{Serpent} define geometry?}

Serpent has a simple yet powerful way of defining geometries. Serpent has 
surfaces, cells and universes. In Serpent, surfaces can be elementary or 
derived. Derived surfaces are those formed by two or more elementary surfaces. 
Serpent offers forty-two (42) different derived surface types \ref{tab:surfaces} for the convenience of the user. Surfaces are numbered to allow identification.

Cells, which can be two or three dimensional, are a delimited part of the space 
formed by surfaces. Cells have names (or numbers) to identify themselves and 
each cell belong to a universe. Cells can be said \texttt{void}) if 
empty, \texttt{outside} if describing a region of space that is not part 
of the model's geometry of filled by another universe. In the latter case the 
keyword used is \texttt{fill}.

But a fundamental concept remains open: what is a universe? A universe is a "filling pattern". In other words, a universe is a domain covering the space where it is defined. Despite the awkward definition, a universe allow the geometry to 
be divided into different separated levels. As a constraint, a universe must 
cover all space in where it is defined. It is, by default, centred at the 
origin and can be rotated and translated at the users will in order to allow 
the construction of complex geometries.

With the concept of universes in mind, is easy to introduce the concept of 
lattices. Lattices are a special type of universes, which are filled with 
regular structures of other universes. Serpent has eight type of lattices. 
Figure \ref{fig:lattice-example} shows a regular lattice [...].


%Serpent has 42 (forty-two) types of surfaces. Their names and the associated
%list of parameters which are used to propertly define them are stored
%in separated data strctures, one holding surfaces names and other keeping
%the parameter list for each surface. These variables are defined in the
%header file \texttt{surface\_types.h}\footnote{It is worth mention
%  that parameters of surfaces are stored in an array of arrays of size
%  two, holding tuples representing the minimum and maximum number of parameters
%  accepted for each surface.}.

% Maybe make a table showing the possible surfaces, theis parameters
% and a short description (image)

\section{Features and limitations}

\section{Development (libraries)}

The chosen toolkit used to develop a visualization software for Serpent input 
geometries is the Visualization Tookit (VTK)\cite{vtk}. It is an open-source, 
freely available software system for, among other applications, visualization of 
scientific data. In the present case, this data is a set of geometrical 
primitives used to model the geometry of a real problem, specifically, a 
nuclear reactor core.

\section{TOUGHTS}

\begin{itemize}

    \item Something I'm wondering: once I can intersect and build elements like in Serpent/MCNP, should I make
      them polydata like unstructured grids?
    \item I maybe should try a first version of code in Python and then code the well-tought version in C++. This would make double the work, but I would practice both languages the way I want.
    \item Attention to messages marked as \textbf{important} in VTK users list, they might be useful to the future problems I'll face when implementing.
      
\end{itemize}

\section{Examples of use}

\section{Conclusions and Future work}

\bibliographystyle{plain}
\bibliography{pp-csg}

\end{document}

